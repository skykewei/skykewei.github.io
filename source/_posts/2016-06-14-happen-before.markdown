---
layout: post
title: "Java内存模型之Happen-Before原则 "
date: 2016-06-14 19:59:54 +0800
comments: true
categories: 并发
---

Java内存模型是描述在并发环境中多线程之间是如何交互的。其中重要的一部分就是Happen-Before原则，具体如下：

## 程序顺序原则 ##

在线程中，指令重排会保证线程内语句执行的**语义**上的一致性.
注意这里说的是语义上的一致性，而不是程序语句上的一致性。

    int a = 0; //语句 1
    int b = 1; //语句 2

上面的代码块从程序语句顺序上讲，语句1在语句2前面，两条语句颠倒顺序成为下面的样子：

	int b = 1; //语句 2
    int a = 0; //语句 1

<!--more-->

这前后两个代码块虽然语句顺序不一致，但是在语义上是一致的，因为两个代码段执行完成后变量`a`和变量`b`的值是一致的。

指令重排是引起一系列并发问题的重要原因。编译器的指令重排必须保证程序代码段在串行执行中的语义保持一致。

之所以会进行指令重排主要是出于提升程序性能，提高CPU的指令吞吐量的考虑，有兴趣的可以去查阅有关资料。

因此当编译器认为必要的时候，会对程序进行指令重排。

## volatile原则 ##

Java中用于线程间通信的volatile变量的写会先发生于volatile变量的读，由此保证volatile变量的可见性。
同时在执行有关volatile读写语句之前，会保证在该volitile语句之前的语句全部执行完毕。

    volatile boolean ok = false; // 语句 1
    int a = 0
    int b = 1
    //thread 1
    a = 2;     //语句 2
    b = 3;     //语句 3
    ok = true; //语句 4
    ...
    //thread 2
    while(!ok){}  //语句 5
    System.out.println("a="+a+",b="+b); //语句 6
       
上一节中我们提到了指令重排会导致程序语句的执行顺序不一定与你写的代码语句的顺序一致。

上面代码段若语句1中变量`ok`没有`volatile`关键字，那么线程1中的语句2、语句3、语句4执行顺序就会被打乱，语句4有可能会被安排在语句2或者语句3之前执行。那么在并发执行环境中，线程2中在语句5处检测到`ok==true`跳出循环时，语句2和语句3还未执行，变量`a`和变量`b`不一定分别为2和3. 有了`volatile`关键字，语句6输出时，一定会有`a=2，b=3`.也就是说线程1在语句4之前的所有操作结果对线程2是可见的。
  
    

## 锁原则 ##

对于并发中的锁的unlock操作一定发生在锁的lock之前。

## 传递性原则 ##

如果事件A发生在B之前，事件B发生在C之前，那么事件A一定发生在C之前

## 线程开始原则 ##

Java的线程需要调用start(),方法启动。start()操作必然要在该线程的所有操作之前执行

## 线程结束原则 ##

线程的所有操作都是在该线程正常结束、或者从Thread.join()调用中成功返回，或着调用Thread.isAlive返回false

## 中断原则 ##

一个线程调用另一个线程的interrupt 操作先于被中断的线程发现中断(通过抛出InterruptedException或者调用isInterrupted和interrupted)

## 对象终结原则 ##

一个对象的构造函数的执行完成先于这个对象的finalizer的开始