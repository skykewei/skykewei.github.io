---
layout: post
title: "Go 并发"
date: 2016-05-31 19:59:21 +0800
comments: true
categories: Go
---

Go并发是以协程(goroutine)为基础的，那么问题来了。
协程是什么？与线程有什么区别联系？Go为什么选择协程而不是线程？

## 协程是什么 ##

在Go中，你可以使用`go f()` 发起一个协程。其中`f()`是Go中的func调用。所以个人认为Go中的协程是一个“函数调用”，是一个执行线。多个“函数调用”之间是并发的关系。

<!--more-->

## 协程与线程区别和联系 ##

不管Go使用什么机制支持并发，但是最终需要拿到底层OS去调用执行，OS才是最终的Go并发的执行者，而我们又知道OS并发靠的是各种process和thread，所以我们可以很自然的想到Go的协程和底层OS的thread或者process之间有一种映射关系。

没错，我们正在进一步接近真相，Go中把协程映射到一组线程上去执行。也就是说多个协程被安排由一个线程去执行。如果熟悉OS调用的童鞋就会知道，进程是OS分配系统资源的基本单位，线程是OS执行调用的基本单位。进程切换和线程切换都需要一定的负载。

Go多个协程由单个线程去执行，但同时又要保证多个协程的并发特性，这是如何做到的？

Go中使用一种叫做`segmented stacks`的技术做到的，这门技术以后再详谈。

那么当某个协程因为某种原因(I/O调用或者其他阻塞的系统调用)被阻塞的时候，执行该协程的线程会如何做？

执行该协程的线程同样被阻塞，此时的线程是无法继续执行分配到它身上的其他协程了，Go的运行环境会把其他协程调度到其他没有被阻塞的线程中。这样就保障了协程之间的并发性。

## Go为什么选择协程而不是线程？##

我们都知道OS中进程切换和线程切换都会有开销，一般来说，一个进行能够拥有上千个线程,具体多少是受到OS的资源限制的。众所周知，线程之所以出现是因为要解决进行切换开销过大并提高并发性。那么协程在线程之后出现，也是有解决线程切换开销和提高并发性的原因。在同等的资源环境下，可以创建成千上万个协程，但线程也就创建数千个。平均下来，协程切换只需要CPU的3个轻量级指令。

# 参考链接 #

[https://golang.org/doc/faq#goroutines](https://golang.org/doc/faq#goroutines)

[https://golang.org/doc/faq#How_is_the_run_time_support_implemented](https://golang.org/doc/faq#How_is_the_run_time_support_implemented)

ps.上面两个链接目前都需要科学上网，是Go的官方网站